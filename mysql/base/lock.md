# 锁

## 1. 锁的使用方式

- 悲观锁
- 乐观锁

## 2. 锁的级别

- 共享锁
- 排他锁
- 意向锁
- 间隙锁

## 3. 锁的粒度

- 行锁
- 表锁
- 页锁

## 4. 悲观锁

### 介绍

- 排它锁，当事务在操作数据时把这部分数据进行锁定，直到操作完毕后再解锁，其他事务操作才可操作该部分数据。
- 实现：大多数情况下依靠数据库的锁机制实现

### 实现 1: for update

- 一般使用 select ...for update 对所选择的数据进行加锁处理
- 本次事务提交之前（事务提交时会释放事务过程中的锁），外界无法修改这些记录

```sql
  set autocommit=0;
  select * from account where name=”Max” for update;
  #这条sql语句锁定了account表中所有符合检索条件（name=”Max”）的记录
  #在MySQL中用悲观锁务必须确定走了索引，而不是全表扫描，否则将会将整个数据表锁住
```

### 实现 2: lock in share mode

- 允许不同事务之前共享加锁读取，但不允许其它事务修改或者加入排他锁
- 如果有修改必须等待一个事务提交完成，才可以执行，容易出现死锁
- select \* from test where id = 1 lock in share mode;

## 5. 乐观锁

### 介绍

- 总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁
- 如果有人在你之前更新了，你的更新应当是被拒绝的，可以让用户重新操作
- 实现：大多数基于数据版本（Version）记录机制实现

### 实现 1：版本号

- 当读取数据时，将 version 字段的值一同读出
- 当数据每更新一次，对此 version 值加一
- 当提交更新的时候，判断当前版本值与第一次取出来的版本值大小，如果相等则予以更新，否则拒绝更新，让用户重新操作。

### 实现 2: cas 算法

- compare and swap
- 需要读写的内存值 V
- 进行比较的值 A
- 拟写入的新值 B
- 当且仅当 V 的值等于 A 时，CAS 通过原子方式用新值 B 来更新 V 的值，否则不会执行任何操作，一般情况下是一个自旋操作，即不断的重试。

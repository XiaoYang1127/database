# count 性能对比

## 说明

### count(主键)

- InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层
- server 层拿到 id 后，判断是不可能为空的，就按行累

### count(1)

- InnoDB 引擎遍历整张表，但不取值
- server 层对于返回的每一行，放一个"1"进去，判断是不可能为空的，按行累加

### count(column_name)

- 如果"字段"是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加；
- 如果"字段"定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加

### count(\*)

- 并不会把全部字段取出来，而是专门做了优化，不取值，按行累加

### 效率

- 按照效率排序的话，count(字段) < count(主键 id) < count(1) ≈ count(\*)
- 所以尽量使用 count(\*)

## select count(\*)对比

- 在 MyISAM 存储引擎中，count()函数是直接读取数据表保存的行记录数并返回
- 在 InnoDB 存储引擎中，count(\*)函数是先从读取表中的数据到内存缓冲区，然后扫描全表获得行记录数的
- 在使用 count 函数中加上 where 条件时，在两个存储引擎中的效果是一样的，都会扫描全表计算某字段有值项的次数
- 由于 MVCC 的原因，InnoDB 表"应该返回多少行"也是不确定的

```
  1. 在默认隔离级别可重复读的情况下，通过MVCC来实现，每一行记录都需要判断自己是否对这个会话可见，
  2. 因此在统计总数量时，InnoDB只好把数据一行一行的读取出来判断，只有当前会话可见的才纳入统计中。
  3. 所以同一时刻不同会话查询到的数量就不一样。
```

- innodb 作出的优化

```
  1. 在InnoDB存储引擎中是以索引组织表的方式存储数据，主键索引树上叶子节点存放在所有的数据，而普通索引树的叶子节点是主键值，
    所以普通索引树会比主键索引树小很多，但是数量是一样的，也就是说遍历主键索引树和普通索引树得到的结果都是一样的。
  2. MySQL就利用了这一特性，在InnoDB中执行 select count(*) from t 语句时，MySQL优化器会找到最小的那棵索引树来遍历，
    这样可能就可以减少加载次数，在一定程度上提升了count(*)的执行效率
```

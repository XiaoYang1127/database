# redis 内存相关问题分析

## 1. 缓存穿透

### 背景

- 用户大量并发请求的数据对应的数据在 redis 和数据库中都不存在，导致尽管数据不存在但还是每次都会进行查 DB

### 解决方案

- 从 DB 中查询出来数据为空，也进行空数据的缓存，并设置过期时间，避免 DB 数据为空也每次都进行数据库查询
- 使用布隆过滤器，但是会增加一定的复杂度及存在一定的误判率

## 2. 缓存雪崩

### 背景

- 数据未加载到缓存中，或者缓存同一时间大面积的失效，从而导致某一时刻所有请求都去查数据库，导致数据库 CPU 和内存负载过高，甚至宕机
- 集体失效事件

### 解决方案

- 事前：高可用架构。主从架构，操作主节点，读写，数据同步到从节点，一旦主节点挂掉，从节点跟上。
- 事中：多级缓存。redis cluster 已经彻底崩溃了，缓存服务实例的 ehcache 的缓存还能起到作用。
- 事后：redis 数据可以恢复，做了备份，redis 数据备份和恢复，redis 重新启动起来

## 3. 缓存击穿

### 背景

- 缓存中的一个 Key，在某个时间点过期的时候，恰好在这个时间点对这个 Key 有大量的并发请求过来
- 这些请求发现缓存过期一般都会从后端 DB 加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端 DB 压垮。

### 解决方案

- 使用互斥锁(mutex key)，对缓存查询加锁，如果 KEY 不存在，就加锁，然后查 DB 入缓存，然后解锁
- 布隆过滤器

## 4. 缓存预热

### 背景

- 缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统
- 避免，用户请求的时候，再去加载相关的数据

### 解决方案

- 起服加载活跃数据
- 定时刷新缓存
- 当上线时，手动执行加载缓存

## 5. 缓存并发

### 背景

- 多个 redis 的 client 同时 set key 引起的并发问题
- redis 自身就是单线程操作，多个 client 并发操作，按照先到先执行的原则，先到的先执行，其余的阻塞

### 解决方案

- 把 redis.set 操作放在队列中使其串行化，必须的一个一个执行

## 6. 缓存更新

### 缓存淘汰的策略有两种：

- 定时去清理过期的缓存
- 当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存

### 缓存算法

- FIFO 算法，First in First out，先进先出，一个数据最先进入缓存中，则应该最早淘汰掉，
  当缓存满的时候，应当把最先进入缓存的数据给淘汰掉。
- LFU 算法：Least Frequently Used，最不经常使用算法
- LRU 算法：Least Recently Used，近期最少使用算法

## 7. 缓存降级

### 背景

- 当访问量剧增、服务出现问题或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的
- 系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级

### 一般

- 比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级

### 警告

- 有些服务在一段时间内成功率有波动（如在 95~100%之间），可以自动降级或人工降级，并发送告警

### 错误

- 比如可用率低于 90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级

### 严重错误

- 比如因为特殊原因数据错误了，此时需要紧急人工降级

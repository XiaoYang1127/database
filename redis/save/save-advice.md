# redis持久化建议


## 1. RDB持久化
### 缺点
* bgsave在进行fork操作时Redis主进程会阻塞
* 子进程向硬盘写数据也会带来IO压力
* RDB每次在fork子进程来执行RDB快照数据文件生成的时候，如果数据文件特别大，
  可能会导致对客户端提供的服务暂停数毫秒，或者甚至数秒；
* 一般不要让RDB的间隔太长，否则每次生成的RDB文件太大了，对Redis本身的性能可能会有影响的

### 优点
* RDB文件紧凑，体积小，网络传输快，适合全量复制
* 恢复速度比AOF快很多
* 选择RDB对Redis的性能更加有利
* RDB更适合用于备份数据库，尤其冷备份
* RDB非常适用于灾难恢复


## 2. AOF持久化
### 缺点
* 向硬盘写数据的频率大大提高(everysec策略下为秒级)，IO压力更大，甚至可能造成AOF追加阻塞问题
* AOF文件的重写与RDB的bgsave类似，会有fork时的阻塞和子进程的IO压力问题
* 相对来说，由于AOF向硬盘中写数据的频率更高，因此对Redis主进程性能的影响会更大
* 文件大、恢复速度慢、对性能影响大

### 优点
* 秒级持久化、兼容性好
* 理论上，通过配置appendfsync everysec，最多丢失2s的数据
* 在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整
* AOF日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写


## 3. 建议
* 如果Redis中的数据完全丢弃也没有关系， 可以不进行任何持久化
* 如果可以接受十几分钟或更多的数据丢失，选择RDB对Redis的性能更加有利
* 如果只能接受秒级别的数据丢失，应该选择AOF
* 主从环境
  * 主服：使用AOF，关闭RDB，关闭自动重写，每天定时开启自动重写任务，从而缩小AOF的文件体积
  * 从服：关闭AOF，使用RDB，15分钟备份一次即可


## 4. 为什么恢复的时候RDB比AOF快？
* AOF存放的指令日志，做数据恢复的时候，其实是要回放和执行所有的指令日志，来恢复出来内存中的所有数据的
* RDB就是一份数据文件，恢复的时候，直接加载到内存中即可


## 5. 写的速度分析
* RDB对Redis对外提供的读写服务，影响非常小，可以让Redis保持高性能，
  因为Redis主进程只需要fork一个子进程，让子进程执行磁盘IO操作来进行RDB持久化即可
* RDB每次写，都是直接写Redis内存，只是在一定的时候，才会将数据写入磁盘中；
* AOF每次都是要写文件的，虽然可以快速写入os cache中，但是还是有一定的时间开销的，速度肯定比RDB略慢一些